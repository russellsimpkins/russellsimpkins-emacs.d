<?php

nytd_require('NYTD/Logger.abstract.php' );
nytd_require('NYTD/RequestInfo.class.php' );
nytd_require('external/FirePHP.class.php');

/**
 *
 * Logging class for webapps.
 *
 * $Id: Web.class.php 32549 2009-06-27 17:34:20Z warren.chin $
 * $Source: /nytd/nytimes/src/cvs/app/websafe/php/lib/NYTD/Logger/Web.class.php,v $
 *
 * Logs to the apache error_log located in /weblogs/amp/apache on your box.
 *  
 * To use:
 * <ul>
 * <li>Instantiate a logger, passing it the name of your app.
 * <li>Set the logging level to something other than LEVEL_NONE (which is the current default)
 * -- available levels are in conf/NYTD/LoggerConfig.class.php
 * <li>Create a symlink in your conf/NYTD directory named LoggerSwitch.class.php that points
 * to LoggerSwitchOn.class.php. This symlink functions as an emergency kill switch. Also, your
 * app will throw errors without it as the config file tries to include a file named
 * LoggerSwitch.class.php.</li>
 * <li>Log with $logger->error(), $logger->info(), etc.</li> 
 * </ul>
 *
 * Some notes:
 * <ul>
 * <li>In production, all calls to setLevel or setLevelMask are ignored and everything just logs
 * at the default level</li>
 * <li>Log messages are truncated at 256 characters (or whatever is defined in
 * LoggerConfig::MAX_MESSAGE_LENGTH)</li>
 * <li>Once the logfile size gets over a certain threshold (currently 2 gb, configurable in config
 * file) logging stops until the logfile is rotated.</li>
 * </ul>
 *
 * @author rachel.camero@nytimes.com 
 */
class NYTD_Logger_Web extends NYTD_Logger {
    
    /**	
     * @var string env what environment are we in?
     */
    private $env = null;
    
    /**
     * @const string PROD string value for production environment,
     * compared against $env to determine environment
     */
    const PROD = "production";

    /**
     * @var string request_id string to uniquely identify this request,
     * can be overriden with setRequestId() if desired
     */
    private $request_id = null;
    
    /**
     * @var NYTD_Logger_Web $instance
     */
    private static $instance;
    
    /**
     * Sends headers needed for Firebug/FirePHP.
     *
     * @var FirePHP
     */
    private $fire_php;
    private $fire_php_enabled;
    
    

    private $cache_vars;    

	/**
	 * @param string $name human-readable name for this logger, optional
     */    
    public static function getInstance( $logger_name = "", $level = NYTD_LoggerConfig::DEFAULT_LEVEL, $enable_firephp = false ) {
        if ( !isset( self::$instance ) ) {
            self::$instance = new NYTD_Logger_Web( $logger_name, $level, $enable_firephp);
        }

        return self::$instance;
    }
    
	/**
	 * @param string $name human-readable name for this logger, optional
     */   
    public function __construct( $logger_name = "", $level = NYTD_LoggerConfig::DEFAULT_LEVEL, $enable_firephp = false ) {
        $this->logger_name = $logger_name;
        $this->setLevel( $level );
        $this->request_id = $this->generateRequestId();
        $this->fire_php_enabled = $enable_firephp;
        
    
        // make sure prod isn't set above error
        if( $this->isProd() && NYTD_LoggerConfig::DEFAULT_LEVEL > NYTD_LoggerConfig::LEVEL_ERROR ) {
            $this->setLevel( NYTD_LoggerConfig::LEVEL_ERROR );
            $this->fire_php_enabled = false;
        }
        
        //If we're able to use firephp load it up and create an instance.
        if($this->fire_php_enabled)
        {
        	nytd_require('external/FirePHP.class.php');
        	$this->fire_php = FirePHP::getInstance(true);
        }
    }

    public function getRequestId() {
        return $this->request_id;
    }

    public function setRequestId( $request_id ) {
        $this->request_id = $request_id;
    }

    private function generateRequestId() {
        $time_array = explode( ' ', microtime() );
        return ((empty($this->logger_name) ? '' : ($this->logger_name . "-")) . ( substr( $time_array[ 0 ], 2 ) . "-" . mt_rand( 100, 10000 ) ));
    }

    /**
     * (re)set the human-readable name for this logger 
     * @param string $logger_name human-readable name for this logger
     */
    public function setLoggerName($logger_name) {
        $this->logger_name = $logger_name;
    }

    /**
     * get the human-readable name for this logger 
     */
    public function getLoggerName() {
        return $this->logger_name;
    }
    
    
	/**
     * Write the given message to the log at the given level.
	 * @param string $message the message to be logged
     * @param integer $level the level of the given message
     */   
    public function log( $message, $level = null ) {

        if( !$this->okForLogging( $level ) || !$this->isRateUnderThreshold() ) {
            return FALSE;
        }

        // truncate messages longer than MAX_MESSAGE_LENGTH characters only if we're at
        // or more critical than the default level (i.e. debug/info never truncated)
        if( $level <= NYTD_LoggerConfig::DEFAULT_LEVEL
            && strlen( $message ) > NYTD_LoggerConfig::MAX_MESSAGE_LENGTH ) {
            if( $this->isProd() ) {
                $message = substr( $message, 0 , NYTD_LoggerConfig::MAX_MESSAGE_LENGTH ) . "...";
            }
            else {
                // in dev and staging, just mark where the truncating would happen
                $message =
                    substr( $message, 0 , NYTD_LoggerConfig::MAX_MESSAGE_LENGTH ) .
                    "... " .
                    substr( $message, NYTD_LoggerConfig::MAX_MESSAGE_LENGTH );  
            }
        }

        error_log( $this->buildMessagePrefix( $level, $this->logger_name ) . $message );
        return TRUE;
    }
    
    
    public function firephp_log($message, $firephp_level = null)
    {
    	if(is_null($this->fire_php) || !$this->fire_php_enabled)
    	{
    		return;
    	}
    	
    	if(is_null($firephp_level))
    	{
    		//For the dumps calls.
    		$this->fire_php->fb($message);
    	}
    	else 
    	{
    		$this->fire_php->fb($message, $firephp_level);
    	}
    }

    /**
     * pretty print an aggregate data structure (including objects) to the log
     * also works fine if thing is a scalar
     *
     * We explicitly pass NYTD_LoggerConfig::LEVEL_DEBUG so as not to have to worry 
     * about string truncation issues if someone were to pass LEVEL_ERROR
     *
     * @param mixed $data
     */
    public function logDumper($data)
    {
    	//Log for fire_php
        $this->firephp_log($data, FirePHP::LOG);
        
        //Log normally
        $out = '';
        ob_start();
        print_r($data);
        $out .= ob_get_contents();
        $this->log($out, NYTD_LoggerConfig::LEVEL_DEBUG);
        ob_end_clean();
      
    }
    
    public function isRateUnderThreshold() {

        $ok = TRUE;

        $curr_time = array_sum( explode( ' ', microtime() ) );

        /*
        0: start time of this interval
        1: number of messages logged in this interval
        2: throttle flag, 0/1 (are we currently throttling or not?)
        3: total messages logged
        4: size of logfile at last check (bytes)
        5: are we currently not logging due to file size?
        */
        $cache_vars = apc_fetch( "logger_web" );
        $interval_start_time = $cache_vars[ 0 ];
        $interval_msgs_logged = $cache_vars[ 1 ] + 1;
        $throttle = $cache_vars[ 2 ];
        $total_msgs_logged = $cache_vars[ 3 ] + 1;
        $current_file_size = $cache_vars[ 4 ];
        $file_too_big = $cache_vars[ 5 ];

        // check file size every X messages
        if( $total_msgs_logged % NYTD_LoggerConfig::SIZE_CHECK_INTERVAL == 0 ) {
            $current_file_size = filesize( NYTD_LoggerConfig::LOGFILE );
            //error_log( "[size] current log size = " . $current_file_size );
            //error_log( "[size] total messages logged: " . $total_msgs_logged );
        }

        // don't log if file size is too big
        if( $current_file_size > NYTD_LoggerConfig::MAX_LOGFILE_SIZE ) {
            // print message if we just stopped logging
            if( $file_too_big == 0 ) {
                error_log( "[NYTD_Logger_Web] logfile size over limit - stopping logging until file is rotated" );
            }
            $file_too_big = 1;
            $ok = FALSE;
        }
        else {
            $file_too_big = 0;
        }
        
        //error_log( "logged " . $msgs_logged . " messages in last " . ( $curr_time - $start_time ) . " seconds" );
        // see if we're over the threshold every interval
        if( $ok && ( ( $curr_time - $interval_start_time ) > NYTD_LoggerConfig::THROTTLE_INTERVAL ) ) {
            
            if( $interval_msgs_logged > NYTD_LoggerConfig::THROTTLE_THRESHOLD ) {
                if( $throttle == 0 ) {
                    // indicate that we just started throttling
                    error_log( "[NYTD_Logger_Web] throttling " );
                }
                else {
                    // we've been logging for at least 1 interval already
                    error_log( "[NYTD_Logger_Web] throttled " . $interval_msgs_logged . " messages" );
                }
                // if we're over our threshold, suppress logging for the next [interval] seconds
                $throttle = 1;
                $ok = FALSE;
            }
            else {
                // if we just stopped throttling, log accordingly
                if( $throttle == 1 ) {
                    error_log( "[NYTD_Logger_Web] throttled " . $interval_msgs_logged . " messages" );
                    error_log( "[NYTD_Logger_Web] resuming normal logging" );       
                }
                $throttle = 0;
            }

            // increment inteval start time and interval message count after every interval
            $interval_start_time = $curr_time;
            $interval_msgs_logged = 0;
        }

        // update array values and store    
        $cache_vars[ 0 ] = $interval_start_time;
        $cache_vars[ 1 ] = $interval_msgs_logged;
        $cache_vars[ 2 ] = $throttle;
        $cache_vars[ 3 ] = $total_msgs_logged;
        $cache_vars[ 4 ] = $current_file_size;
        $cache_vars[ 5 ] = $file_too_big;

        apc_store( "logger_web", new ArrayObject( $cache_vars ) );
        
        return ( ( !$ok || $throttle == 1 ) ? false : true );
    }
    
    /**
     * Convenience method for lodding at the error level.
	 * @param string $message the message to be logged
     */
    public function error( $message ) {
 
    	$this->firephp_log($message, FirePHP::ERROR);
        return $this->log( $message, NYTD_LoggerConfig::LEVEL_ERROR );
    }
    
	/**
     * Convenience method for logging at the warning level.
	 * @param string $message the message to be logged
     */    
    public function warning( $message ) {
    	
    	$this->firephp_log($message, FirePHP::WARN);
        return $this->log( $message, NYTD_LoggerConfig::LEVEL_WARNING );
    }
    
    /**
     * Convenience method for lodding at the info level.
	 * @param string $message the message to be logged
     */
    public function info( $message ) {
    	$this->firephp_log($message, FirePHP::INFO);
        return $this->log( $message, NYTD_LoggerConfig::LEVEL_INFO );
    }
    
 	/**
     * Convenience method for lodding at the debug level.
	 * @param string $message the message to be logged
     */   
    public function debug( $message ) {
    	$this->firephp_log($message, FirePHP::LOG);
        return $this->log( $message, NYTD_LoggerConfig::LEVEL_DEBUG );
    }

    /**
     * Convenience method for mapping log levels to their names.
     * @param integer $level the log level
     * @return the string representation of the given log level
     */
    private function levelAsString( $level ) {
        $levels = array(
            NYTD_LoggerConfig::LEVEL_ERROR   => 'error',
            NYTD_LoggerConfig::LEVEL_WARNING => 'warning',
            NYTD_LoggerConfig::LEVEL_INFO    => 'info',
            NYTD_LoggerConfig::LEVEL_DEBUG   => 'debug'
        );

        return $levels[ $level ];
    }

    /**
     * Constructs the metadata we put at the beginning of each log message.
     * @return string holding the log message prefix
     */
    private function buildMessagePrefix( $level, $name ) {
        $message_prefix = "[" . $this->getTimestamp() . "] ";
        $message_prefix = $message_prefix . "[" . $this->getRequestId() . "] ";
        if( $name != "" ) {
            $message_prefix = $message_prefix . "[" . $name . "] ";
        }
        $message_prefix =  $message_prefix . "[" . $this->levelAsString( $level ) . "] ";

        return $message_prefix;
    }
    
    /**
     * Returns the current time in a log-friendly format, down to the microsecond.
     * @return a microsecond timestamp
     */
    private function getTimestamp() {
        $time_array = explode( ' ', microtime() );
        return strftime( "%Y-%m-%d %T", strtotime( "@" . $time_array[ 1 ] ) )
            . substr( $time_array[ 0 ], 1 );
    }
    
    /**
     * Encapsulates prod check.
     * @return true if we're in prod, false if we're not or were unable to
     * determine what environment we're in
     */
    public function isProd() {

        if( $this->env == null ) {
            $server_config = NYTD_RequestInfo::getNYTServerConfig();
            $this->env = $server_config["SERVERTYPE"];
            if( !$this->env ) {
                $this->env = self::PROD;
            }
        }

        return ( $this->env == self::PROD );
    }
}
