<?php
/**
 * A class to provide basic DAO features. Our storage is relatively
 * straight forward, see at the bottom
 */
class NYTD_UserPrefs_APIKeys_DAO extends NYTD_UserPrefs_APIKeys_BaseDAO {
  
  /**
   * This function will create a new account for you. It assumes that
   * you know how you want to create your private and public key pairs.
   *
   * @param privateKey String some private key
   * @param publicKey String some public key
   * @return Hash 
   *   result['status'] Integer 1 for success 0 for failure
   *   result['reason'] String if a failure, some reason
   *   result['private-token'] String the token you will use in the future to hash with the hour
   *   result['key-id'] String the key you will pass
   *   result['expires-on'] Integer unix date format when this account will expire
   */
  public function createAccount( &$privateKey, &$publicKey ) {

    $expiresOn = $this->calculateExpiresDate();
    $createdOn = date('Y-m-d H:i:s',time());
    $sql = "call NYT_UserProfile_APIKeys_Insert (%i,%s,%s,%s,%s,%s)";
    $tries = 0;
    while ($tries++ < NYTD_UserPrefs_APIKeys_Config::MAX_CREATE_TRIES) {
      $keyId        = $this->generateKeyId();
      $privateToken = $this->generatePrivateToken();
      $params       = array($keyId,$privateKey,$publicKey,$privateToken,$createdOn,$expiresOn);
      try {
        $dbresult   = $this->executeDBQuery($sql,$params);
      } catch(Exception $e) {
        if ($tries == NYTD_UserPrefs_APIKeys_Config::MAX_CREATE_TRIES) {
          return array('status'=>0, 'reason'=>"Database exception: " . print_r($e, true));
        }
      }

      // a success should send us back the pk.
      if (!empty($dbresult) && !empty($dbresult['account_id'])) {
        break;
      }
    }

    if (!empty($dbresult) && !empty($dbresult['account_id'])) {
      $result = array();
      $result['status'] = 1;
      $result['private-token']=$privateToken;
      $result['key-id']=$keyId;
      $result['expires-on']=$expiresOn;
    } else {
      $result['status'] = 0;
      $result['reason'] = "Unable to create an account. Please try again at a later date.";
    }
    return $result;
  }
  
  /**
   * This function will return the public key and the private token for 
   * a given keyId and the account has not expired.
   *
   * @param keyId - String/Integer - a valid key
   * @return Hash 
   *   result['status'] Integer 1 == success 0 == failure
   *   result['private-token'] String the private token
   *   result['public-key'] String this account's public key
   */
  public function getAccountPublicAndToken( &$keyId ) {
    $sql = "call NYT_UserProfile_APIKeys_SelectBasic(?)";
    $params = array($keyId);
    try {
      $result = $this->executeDBQuery($sql,$params);
      $retval = array();
      if (!empty($result)) {
        // this must have worked
        $retval['status'] = 1;
        $retval['private-token'] = $result['data']['private_token'];
        $retval['public-key'] = $result['data']['public_key'];
      } else {
        $retval['status'] = 0;
        $retval['reason'] = "Unable to get any data with key: $keyId";
      }
      return $retval;
    } catch(Exception $e) {
      return array('status'=>0, 'reason'=>"Database exception: " . print_r($e, true));
    }
  }

  /**
   * Get the expire date as unix time for the key passed in
   *
   * @param keyId int - the key for the account
   * @return Hash 
   *    result['status'] Integer 1 == success 0 == failure
   *    result['reason'] String if a failure, then this is the reason
   *    result['expires-on'] Integer unix time for the expires date
   *
   */
  public function fetchExpiresDate( &$keyId ) {
    if (empty($keyId)) return null;
    $sql = "call NYT_UserProfile_APIKeys_SelectExpires(%i)";
    $params = array($keyId);
    $retval = array();
    try {
      $result = $this->executeDBQuery($sql,$params);
      if (!empty($result)) {
        array_shift($result);
        // this must have worked
        $retval['status'] = 1;
        $retval['expires-on'] = strtotime($result['expires_on']);
      } else {
        $retval['status'] = 0;
        $retval['reason'] = "Unable to get any data with key: $keyId";
      }
      return $retval;
    } catch(Exception $e) {
      return array('status'=>0, 'reason'=>"Database exception: " . print_r($e, true));
    }
  }
  
  /**
   * This function calls the database and attempts to get the account
   * id for this account using the key id
   * @param keyId Integer a valid key in the db
   * @return Hash 
   *   result['status'] Integer 1 = success 0 = failure
   *   result['reason'] String if a failure, then this is the reason
   *   result['account-id'] Integer non-zero, positive integer - pk
   */
  public function isAccountValid( &$keyId ) {
    if (empty($keyId)) return false;
    $sql = "call NYT_UserProfile_APIKeys_ValidAccount(%i);";
    $retval = array();
    $params = array($keyId);
    try {
      $result = $this->executeDBQuery($sql,$params);
      if (!empty($result)) {
        array_shift($result);
        // this must have worked
        $retval['status'] = 1;
        $retval['account-id'] = $result['account_id'];
      } else {
        $retval['status'] = 0;
        $retval['reason'] = "Unable to get any data with key: $keyId";
      }
      return $retval;
    } catch(Exception $e) {
      return array('status'=>0, 'reason'=>"Database exception: " . print_r($e, true));
    }
  }

  /**
   * Set the expires date to yesterday to expire the account
   *
   * @param keyId Integer a valid key id
   * @return null
   */
  public function expireAccount( &$keyId ) {
    if (empty($keyId)) return;
    $sql = "call NYT_UserProfile_APIKeys_ExpireAccount(%i)";
    $params = array($keyId);
    try {
      $result = $this->executeDBQuery($sql,$params);
      return;
    } catch(Exception $e) {
      return array('status'=>0, 'reason'=>"Database exception: " . print_r($e, true));
    }
  }
  
  /**
   * This function will update the db with the new privateKey and
   * publicKey we will also calculate a new expires time and update
   * the account with that data.
   *
   * @param keyId Integer the account key_id
   * @param privateKey String the private key
   * @param publicKey String the public key
   * @return Hash 
   *   result['status'] Integer 1 == success 0 == failure
   *   result['reason'] String if a failure, some reason
   *   result['expires-on'] Integer unix time the account expires
   *             
   */
  public function renewKey( &$keyId, &$privateKey, &$publicKey ) {
    if (empty($keyId) || empty($privateKey) || empty($publicKey)) {
      return array('status'=>0, 'reason'=>"Empty values sent to renewKey function.");
    }
    $expiresOn = $this->calculateExpiresDate();
    $sql = "call NYT_UserProfile_APIKeys_RenewKey(%i, %s, $s, $s)";
    $params = array( $keyId, $privateKey, $publicKey, $expiresOn);
    try {
      $result = $this->executeDBQuery($sql,$params);
      return array('status'=>1,'expires-on'=>$expiresOn);
    } catch(Exception $e) {
      throw new Exception($e);
      return array('status'=>0, 'reason'=>"Database exception: " . print_r($e, true));
    }
  }

  /**
   * Create a mysql date for when this key will expire
   *
   * @return String formatted for mysql date as string
   */
  private function calculateExpiresDate() {
    $daysOut=86400 * KEY_GOOD_FOR_DAYS;
    $dateTime = time() + $daysOut;
    return date('Y-m-d H:i:s',$dateTime);
  }

  /**
   * We need to generate a random key that is best suited to be numeric
   * Given that it is generated we will have to create an account to secure
   * the key is then taken before updates
   */
  private function generateKeyId() {
    return crc32(rand(0,time()));
  }

  /**
   * Generate a pseudo random secret token
   * 
   * @return String - md5 you
   */
  private function generatePrivateToken() {
    return md5(rand(0,time()));
  }
}
